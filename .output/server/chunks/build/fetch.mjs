import { ref, shallowRef, toRef, getCurrentInstance, onServerPrefetch, unref, computed, toValue, reactive } from 'vue';
import { M as hash } from '../nitro/nitro.mjs';
import { _, l, u as u$1, a as u$2 } from './server.mjs';

function n(n){var r;return n||(n=_()),null==(r=n.ssrContext)?void 0:r.event}function r(){var t;return (null==(t=n())?void 0:t.$fetch)||globalThis.$fetch}

function c(...c){var u;const y="string"==typeof c[c.length-1]?c.pop():void 0;"string"!=typeof c[0]&&c.unshift(y);let[_$1,m,p={}]=c;if("string"!=typeof _$1)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof m)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const f=_(),v=m;p.server??(p.server=true),p.default??(p.default=()=>l.value),p.getCachedData??(p.getCachedData=()=>f.isHydrating?f.payload.data[_$1]:f.static.data[_$1]),p.lazy??(p.lazy=false),p.immediate??(p.immediate=true),p.deep??(p.deep=l.deep),p.dedupe??(p.dedupe="cancel");const D=p.getCachedData(_$1,f),h=null!=D;if(!f._asyncData[_$1]||!p.immediate){(u=f.payload._errors)[_$1]??(u[_$1]=l.errorValue);const r=p.deep?ref:shallowRef;f._asyncData[_$1]={data:r(h?D:p.default()),pending:ref(!h),error:toRef(f.payload._errors,_$1),status:ref("idle"),_default:p.default};}const P={...f._asyncData[_$1]};delete P._default,P.refresh=P.execute=(e={})=>{if(f._asyncDataPromises[_$1]){if("defer"===(a=e.dedupe??p.dedupe)||false===a)return f._asyncDataPromises[_$1];f._asyncDataPromises[_$1].cancelled=true;}var a;if(e._initial||f.isHydrating&&false!==e._initial){const a=e._initial?D:p.getCachedData(_$1,f);if(null!=a)return Promise.resolve(a)}P.pending.value=true,P.status.value="pending";const t=new Promise(((e,a)=>{try{e(v(f));}catch(t){a(t);}})).then((async e=>{if(t.cancelled)return f._asyncDataPromises[_$1];let a=e;p.transform&&(a=await p.transform(e)),p.pick&&(a=function(e,a){const t={};for(const r of a)t[r]=e[r];return t}(a,p.pick)),f.payload.data[_$1]=a,P.data.value=a,P.error.value=l.errorValue,P.status.value="success";})).catch((e=>{if(t.cancelled)return f._asyncDataPromises[_$1];P.error.value=u$1(e),P.data.value=unref(p.default()),P.status.value="error";})).finally((()=>{t.cancelled||(P.pending.value=false,delete f._asyncDataPromises[_$1]);}));return f._asyncDataPromises[_$1]=t,f._asyncDataPromises[_$1]},P.clear=()=>function(e,a){a in e.payload.data&&(e.payload.data[a]=void 0);a in e.payload._errors&&(e.payload._errors[a]=l.errorValue);e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=l.errorValue,e._asyncData[a].pending.value=false,e._asyncData[a].status.value="idle");a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=true),e._asyncDataPromises[a]=void 0);}(f,_$1);if(false!==p.server&&f.payload.serverRendered&&p.immediate){const e=P.refresh({_initial:true});getCurrentInstance()?onServerPrefetch((()=>e)):f.hook("app:created",(async()=>{await e;}));}const g=Promise.resolve(f._asyncDataPromises[_$1]).then((()=>P));return Object.assign(g,P),g}

function i(i,l,c$1){const[f={},m]="string"==typeof l?[{},l]:[l,c$1],p=computed((()=>toValue(i))),d=f.key||hash([m,"string"==typeof p.value?p.value:"",...u(f)]);if(!d||"string"!=typeof d)throw new TypeError("[nuxt] [useFetch] key must be a string: "+d);if(!i)throw new Error("[nuxt] [useFetch] request is missing.");const h=d===m?"$f"+d:d;if(!f.baseURL&&"string"==typeof p.value&&"/"===p.value[0]&&"/"===p.value[1])throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:v,lazy:b,default:y,transform:g,pick:w,watch:_,immediate:x,getCachedData:k,deep:E,dedupe:U,...D}=f,R=reactive({...u$2,...D,cache:"boolean"==typeof f.cache?void 0:f.cache}),q={server:v,lazy:b,default:y,transform:g,pick:w,immediate:x,getCachedData:k,deep:E,dedupe:U,watch:false===_?[]:[R,p,..._||[]]};let T;return c(h,(()=>{var e;null==(e=null==T?void 0:T.abort)||e.call(T,new DOMException("Request aborted as another request to the same endpoint was initiated.","AbortError")),T="undefined"!=typeof AbortController?new AbortController:{};const o=toValue(f.timeout);let r$1;o&&(r$1=setTimeout((()=>T.abort(new DOMException("Request aborted due to timeout.","AbortError"))),o),T.signal.onabort=()=>clearTimeout(r$1));let a=f.$fetch||globalThis.$fetch;if(!f.$fetch){"string"==typeof p.value&&"/"===p.value[0]&&(!toValue(f.baseURL)||"/"===toValue(f.baseURL)[0])&&(a=r());}return a(p.value,{signal:T.signal,...R}).finally((()=>{clearTimeout(r$1);}))}),q)}function u(e){var o;const r=[(null==(o=toValue(e.method))?void 0:o.toUpperCase())||"GET",toValue(e.baseURL)];for(const s of [e.params||e.query]){const e=toValue(s);if(!e)continue;const o={};for(const[r,s]of Object.entries(e))o[toValue(r)]=toValue(s);r.push(o);}return r}

export { i };
//# sourceMappingURL=fetch.mjs.map
